##Notes on sql tables to be made
-------------------------------------------------

dont make classes for relidtable an uuidtable

let's try to keep as object oriented as possible
-----------------------------------------------

basically create/insert and read methods are very common

------------------------
#for Users: ( ALL DONE , TESTED )

1. create a user:(create)
given userid, password - convert to token in your model - classwritten in utils, role integer, token call method in utils,  keyenabled by default 1 for role >=2 only

add later: as soon as a user is created also add a row to tasks with iscrawled 0 - individual task

2. escalalate/demote a user
update to new role given userid  (role_update)

3. get user object given userid (get object)

4. validate user and password : password given will be simple, use token utils (validate)

5. all the above things will be easy if you can use a self introspective algo which when called update - automatically makes the update easier by reading the object

6. validate if token and userid given is from a valid row and that row is enabled: all this check can be done in a single query

7. add an entry to tasks table for every user created. (TODO)

-----------------------------------------------
#for TASKS:

1. create -  in constructor all will be given, except taskid, as it is generated by the mysql:
createdate will be yours
how i worked on this from the old uuidtable work-- note the lastrowid!
class Entity:


    def __init__(self, name):
        self.uuid = None
        self.name = name ##TODO: but what if the primary name changes?
        #self.uri = uri #TODO: will decide afterwards
        from app.constants import META_TABLE_UUID
        self.tablename  = META_TABLE_UUID
        self.dbwrap = MetaSQLDB()

    def create(self):
        query = 'insert into uuidtable(name) values("%s");'
        query = query %(self.name)


        cursor = self.dbwrap.connectAndCursor()
        numrows = cursor.execute(query)
        self.uuid =  cursor.lastrowid
        self.dbwrap.commitAndClose() ##what if something breaks? TODO!

        return numrows

#how to handle the date formats - will have to write some utils? No I think..

-----------------------------------------------
#for TASKUSERS:

add a user to a task
if the task iscrawled = 0 cannot add any other user
task and user both primary key together - change if not done
whenever a task ic created by an owner -  also add that user to the task here

----------------------------------------------------------
#for TASKLOG: do this work in the last: moderate imp

insert a task's log
dumpdate will be generated by db or you
get dumpdate from taskid or object

-----------------------------------------------
#for changetable:

changeid will be automatically generated, so use cursor.lasrowid to get that as shown above
create a change
read a change - the change id will be read and then used in many places, so this method is imp
get change object by changeid
verifydate will be generated by you or db - now it will be done by neo4j timestamp method
pushdate will be given
fetchdate will be given - how to handle the date formats - will have to write some utils?
DATE_FORMAT is in constants to be used alongwith datetime

------------------------------------------------------

#for uuidlabels:

insert new - all will be given
for a change id generate list of strings for changes done :
        added label to node with uuid,
        delete label to node with uuid
        --return a list
str for a rwo should be 'changeid added/deleted label <this> to/from node with uuid'  
changetype: 1 - insert, 0 delete for your info
given a node and a label: get latest changeid
given a node uuid - get the list of strings for the latestchangeid -changeid is auto inc so obvsly the higest in such a case is the best
also, for now, only label additions exist in our case
----------------------------------------------

similar for relidtables

-----------------------------------------

for uuidprops:

isnert new - all will be given
oldpropval can be None/null or newpropval can be None/null, should not be an issue but never both

info:
changetype 0 - deleted a prop so newval will be None
changetype 1 - inserted a prop so oldval will be None
changetype 2 - modified a prop so nothing will ne None/null

given a uuid and prop: get latest changeid
str for a rwo should be 'changeid added/deleted/modified prop <this> for node with uuid'

for a change id generate list of strings for changes done :
        added prop to node with uuid,
        deleted prop from node with uuid
        --return a list

given a node uuid - get the list of strings for the latestchangeid -changeid is auto inc so obvsly the higest in such a case is the best
-------------------------------------------------------

#for uuidimage:

uuid: foregin key, primary - if primary creates problem make another imageid for the same
image: column with blob object, can be NULL
addedby: userd foreign key
addedat: datetime

this is just for flow, and test, so that blob handling is done: can test on user pages
upload button : route to flask : get binary data : convert to blob object : push to table: with a session['userid'] for now
updload button overwrites create or modify if not already inserted
read image : write in guest for now code to return blob object and render image: /imageuuid/345/ : such that this works fine: in any of our pages
<img src="http://localhost:5000/guest/imageuuid/77/"/>

------------------------------------------------------------
